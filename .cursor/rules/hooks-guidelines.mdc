---
description: "Conventions for custom React hooks in the hooks/ directory, focusing on state management, side-effect handling, and integration with external state libraries."
globs: hooks/**/*
---
The `hooks/` directory contains reusable React hooks to encapsulate stateful or side-effect logic. These custom hooks should simplify components by abstracting complex logic. Follow these rules for hooks:

- **Naming & Purpose:** Always prefix custom hook names with `use`. The name should reflect its role, e.g. `useAuth()` for authentication logic or `useWindowSize()` for a responsive hook. Each hook should serve a clear purpose and ideally **encapsulate one piece of logic or behavior** (such as fetching a resource, managing a form, or handling an event listener).
- **State Management with Hooks:** Use hooks to manage state that needs to be shared or abstracted away from components. For example, if multiple components need the same data or logic (like a useToggle or a useFetch hook), implement it here. Internally, utilize React state and effects as needed (useState, useReducer, useEffect, etc.), but **avoid side effects on initial load** unless necessary. If a hook does trigger side effects (like data fetching), document this clearly in its comments.
- **Encapsulate Data Fetching with React Query:** If the app uses **Tanstack Query (React Query)**, consider creating hooks that wrap `useQuery` and `useMutation` calls. For instance, a `useUsers()` hook can internally call `useQuery('users', fetchUsers)`. This provides a simple interface to components and centralizes data fetching logic. Configure caching, refetch intervals, and error handling within these hooks so components don’t need to handle those details. Similarly, create hooks for mutations like `useCreateUser()` wrapping a `useMutation`.
- **Side Effects and Cleanup:** For hooks that interact with external systems (e.g., event listeners, subscriptions, timers), ensure to handle setup and cleanup properly using `useEffect` within the hook. Always return a cleanup function in the effect to avoid memory leaks. For example, a `useDocumentTitle(title)` hook might set `document.title` and return a cleanup to reset it if needed (or set previous title).
- **Return Values:** Design hook return values for clarity and flexibility. Common patterns: return an array `[value, setter]` for simple state hooks (mimicking useState), or return an object for more complex hooks (e.g., `{ data, error, isLoading, refetch }` for a data hook). Document what the hook returns and any function it exposes. Ensure the consumer of the hook has everything needed to use it effectively (for example, if a hook manages form state, it might return `{ values, errors, handleChange, handleSubmit }`).
- **Context and Hooks:** Use React Context together with custom hooks to provide global or shared state. For example, if you have an AuthContext, create a `useAuth` hook that internally uses `useContext(AuthContext)`. This hides implementation details from components and provides a simple API. Ensure context providers are placed appropriately (likely in `app/layout.tsx` or `app/providers.tsx`) so that these hooks can access the context.
- **Avoid Heavy Logic in Components:** If you notice a component contains a lot of complex logic (data transformations, multiple useEffect calls, intricate state management), consider extracting that into a hook in this directory. This keeps components cleaner. For instance, a complicated filtering logic can live in a `useFilter(initialData)` hook, which returns filtered results and any filter setters.
- **Error Handling in Hooks:** If a hook performs an operation that can fail (like fetching data), handle errors gracefully. For hooks wrapping `useQuery`, errors can be part of the returned state (`error` object). For custom async operations inside hooks (like using fetch or WebSocket), catch errors and perhaps return them or handle internally (maybe retry logic). Document how errors manifest to the hook consumer (e.g., do you return an `error` or throw inside the hook).
- **Reusability and Independence:** Hooks should be as reusable as possible. Do not directly reference UI or DOM elements inside a hook (those belong in components). Instead, if needed, a hook can return callbacks that components attach to events. For example, a `useScrollFreeze()` hook might return a `enableScroll` and `disableScroll` function for the component to call (rather than the hook manipulating specific component’s DOM). This separates concerns and makes the hook usable in any component.