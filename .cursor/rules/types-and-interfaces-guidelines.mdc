---
description: "Conventions for defining and using TypeScript types in the types/ directory to maintain strong typing across the codebase."
globs: types/**/*
---
The `types/` directory contains shared TypeScript type definitions, interfaces, and possibly schema definitions that are used throughout the project. These guidelines ensure types are clear and maintainable:

- **Global vs Local Types:** Use this directory for types that are used in multiple places or represent core domain models (e.g., `User`, `Product`, etc.). Co-locate very local types (used only in one file) within that file or feature directory to avoid cluttering global namespace. When a type grows or starts being used in many modules, move it to `types/` so it can be imported universally.
- **Naming Conventions:** Name interfaces and types with PascalCase. For interfaces that describe an object shape, prefer nouns (e.g., `User`, `OrderDetails`). You do *not* need to prefix interfaces with “I” (e.g., use `User` rather than `IUser` for simplicity). For utility or generic types, make names descriptive (e.g., `ApiResponse<T>` or `PaginationParams`). If a type is a union, sometimes using a suffix can help (e.g., `UserRoleUnion` or `UserRoleType` if `UserRole` is already an enum). Ensure each name is unique and does not collide with existing types or global names.
- **Type vs Interface Usage:** Use **interface** for defining object shapes, especially for things like function props (so they can be extended if needed). Use **type aliases** for union types, function signatures, or complex mapped types. For example, `type Color = 'primary' | 'secondary' | 'tertiary';` or `type ClickHandler = (event: MouseEvent) => void;`. In general, follow a consistent approach – interfaces for objects/data models and types for everything else.
- **Immutability and Readonly:** When defining types for props or objects that shouldn’t be modified, consider marking them as `readonly` (or using `Readonly<T>` utility type). This prevents accidental mutations and clearly communicates intent. For example, if you have a configuration object type that should not be changed at runtime, you can define it as `interface Config { readonly apiUrl: string; readonly timeout: number; }`.
- **Complex Types (Utility Types):** Leverage TypeScript’s utility types to avoid repetition. For instance, use `Partial<T>` for optional versions of a type, `Pick<T, 'foo' | 'bar'>` to select specific fields, etc., rather than writing new types manually. If you find yourself writing similar types multiple times, consider abstracting with a generic. However, keep types understandable – overly clever type gymnastics can reduce clarity. Include comments to explain any tricky generic types or mapped types.
- **External Data Schemas:** If you interact with external APIs or databases, define TypeScript types for those responses/entities in this folder. For example, if there’s a REST API responding with a certain JSON shape, create a `types/ApiResponses.ts` to define those. This helps ensure the rest of the code doesn’t use `any` when dealing with external data. If using something like Zod for runtime validation, you can derive types from schemas (`export type User = z.infer<typeof UserSchema>`).
- **File Organization:** Split type definitions into multiple files by domain or feature. For example, `types/user.ts` could contain all user-related types, `types/api.ts` for API response types, `types/forms.ts` for form field types, etc. This prevents one giant file and makes it easier to find definitions. Index them in `types/index.ts` if needed for convenience imports (e.g., `import { User, Order } from '@/types';`).
- **Avoid Duplicating Types:** Do not redefine types that can be imported from libraries or built-ins. For instance, use `React.ReactNode` for children, or use types provided by Next.js (like NextAuth’s types for auth, or Next.js types for `GetStaticProps` if applicable) instead of defining your own. Also, if a type is defined in one file (say, a `User` interface in `types/user.ts`), import that everywhere instead of redefining a similar structure in another file. This ensures one source of truth for each major type.
- **Updating Types:** When application requirements change (e.g., a field is added to an API response), update the corresponding type in this directory promptly. This will help TypeScript highlight all the places in code that need to handle the new or changed field, making refactoring easier and safer. Always keep types in sync with the real data structures.
