---
description: "Guidelines for API route handlers in app/api, ensuring they remain lean and follow Next.js conventions (if server actions cannot be used)."
globs: app/api/**/*
---
The `app/api/` directory contains API endpoint route handlers (Next.js App Router API routes). These are server-side functions that respond to HTTP requests. While we prefer Server Actions for form interactions, sometimes dedicated API routes are necessary (for external clients or complex interactions). Follow these practices for any code in `app/api`:

- **Scoped and Purposeful:** Each API route (defined by a `route.ts` or `route.js` file) should have a single purpose (e.g., `/api/users` to handle user-related requests). Keep the logic focused on the request at hand – validate input, perform the needed operation (e.g., database call or third-party API call), and return a response. Do not clutter one endpoint with multiple unrelated actions.
- **Use HTTP Standards:** Follow RESTful conventions for methods and status codes. For example, use GET for retrieval, POST for creation, PUT/PATCH for updates, DELETE for deletion. Return appropriate HTTP status codes (200 for success with data, 201 for created, 400 for bad request, 401/403 for auth errors, 500 for server errors, etc.). Also, structure JSON responses with clear keys. For consistency, you might return an object like `{ success: boolean, data: ..., error: ... }` or follow whatever response shape the project standardizes on.
- **Input Validation:** Validate and sanitize request inputs at the top of the handler. If expecting a JSON body, check required fields and types (you can use Zod or a similar schema validator for this, or manual checks). If query parameters are used, validate their presence/format. **Reject bad input early** by returning a 400 with an error message rather than proceeding with invalid data. This not only prevents errors down the line but also improves security.
- **Lean Business Logic:** Keep heavy business logic out of the route file. If an API route needs to perform complex operations, delegate that to functions in `lib/` or `utils/`. For example, if handling an image upload or a payment webhook, the route should parse the request and then call a helper (e.g., `await processPayment(data)` from a lib module). This makes the route easier to read and test, and other parts of the app could reuse that logic if needed.
- **Authentication & Authorization:** If the project requires auth on certain endpoints, use Next.js middleware or checks within the route. For example, verify JWT or session cookies before performing the action. If using NextAuth or a similar auth solution, utilize its helpers (like getting the current session user) at the start of the handler. Return 401/403 if the user is not authenticated or not allowed to perform the action. Keep these checks consistent across routes.
- **Error Handling:** Catch errors within the route handler and return a controlled response. Avoid letting exceptions bubble up unhandled (which would return a generic 500). For instance, wrap database calls in try/catch and return a 500 with a message (or a specific error code if the error is known, like a 409 for duplicate entries, etc.). Log the error to the console (or a logging service) for debugging, but do not expose internal error details to the client.
- **Performance Considerations:** API routes run on the server for each request, so ensure they are efficient. Use caching headers if appropriate (e.g., if an endpoint can be cached, set `Cache-Control` headers). Avoid doing N+1 database queries – batch or use appropriate filtering in queries. If an API route is heavy and gets called frequently, consider moving some of its work to a background job or using incremental static regeneration if the data can be slightly stale.
- **Consistency with Server Actions:** Prefer **Server Actions** for form submissions from within the app, as they are more tightly integrated with the UI and avoid extra fetch calls. Reserve dedicated API routes for cases like: third-party integrations (webhooks from an external service hitting your app), providing data to non-Next.js clients, or complex interactions that don’t fit the form paradigm. By following this rule, most internal interactions remain simple, and `app/api` routes are only used when necessary, keeping the API surface small and focused.