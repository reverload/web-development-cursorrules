---
description: "Guidelines for the lib/ directory, which holds modules for external integrations, single-instance services, and other non-UI logic (e.g., clients, SDK usage, configuration)."
globs: lib/**/*
---
The `lib/` directory is for modules that are neither React components nor simple utilities, but rather **libraries or services** integrated into our application. This might include API clients, authentication setup, third-party SDK configurations, or other shared logic that doesn’t fit in components/hooks. Guidelines for lib modules:

- **Encapsulate External Integrations:** Use `lib/` to wrap external services or SDKs so the rest of the app can use a clean interface. For example, if using **Vercel AI SDK**, have a module like `lib/ai.ts` or a directory `lib/ai/*` that initializes and exposes functions for AI interactions (such as a function to call the AI chat completion API). This way, components and hooks can import from `lib/ai` instead of dealing with low-level SDK details each time. Keep these integration points centralized.
- **Singletons and Instances:** If a library requires setting up a singleton (e.g., a database connection, an Axios instance, a Tanstack Query client provider, etc.), do that in `lib/`. For instance, create `lib/apiClient.ts` to configure Axios or `lib/queryClient.ts` for a pre-configured QueryClient. This ensures consistency (everyone uses the same instance/config) and simplifies changes (update config in one place). Make sure to handle initialization carefully to avoid issues in Next’s server environment (e.g., check for environment only on server, etc.).
- **Utility vs Lib Distinction:** Generally, if something is purely a function with no external dependencies or side effects, it belongs in `utils/`. If it involves an external library or a complex service, it belongs in `lib/`. For example, a function to format a date is a util, but a function that fetches data from an external API might belong in `lib` (especially if using fetch with specific options or an SDK). When in doubt, consider how it’s used: if it’s part of the app’s core business logic or interacts with outside systems, `lib` is appropriate.
- **Organize by Domain or Service:** Structure the `lib` folder by grouping related functionality. You might have `lib/auth.ts` for authentication-related helpers (or `lib/auth/` with multiple files, like `auth/jwt.ts`, `auth/client.ts` for an Auth SDK, etc.), `lib/db.ts` for database connection (if any), `lib/analytics.ts` for analytics integration, and so on. This makes it easy to locate integration code for a particular concern.
- **Export Clean APIs:** Modules in `lib` should expose functions or objects that the rest of the app can use without needing to know implementation details. For example, if using the Vercel AI SDK to generate text, you might expose a function `generateProductDescription(product): Promise<string>` from `lib/ai.ts` – internally it calls the SDK’s API with our configuration. The component that needs this just calls the function and awaits the result. This separation makes it easier to modify or replace the underlying service if needed.
- **Server vs Client Considerations:** Be mindful of Next.js’s environment. Some lib modules might only work on the server (e.g., Node-specific code) and some only on client. If using a module on the client (like a third-party JS SDK for analytics), ensure it doesn’t accidentally run on the server (guard with `typeof window !== 'undefined'` or only import it in a client component or effect). Conversely, for server-only code (like a database client), ensure it’s not imported into client-side bundles. Document any such constraints at the top of the module (e.g., “// This module is intended for server-side use only”).
- **Configuration and Environment Variables:** If a lib module depends on environment variables or configuration, load them in that module (using `process.env` on server, or using Next’s runtime config if needed). Validate that required env vars are present at startup (throw a clear error if something like `process.env.API_KEY` is missing). This way, any misconfiguration is caught early. Centralizing config access in lib modules (rather than spreading `process.env` accesses all over) also makes the codebase cleaner and more secure.
- **Error Handling & Logging:** Within lib functions, handle errors from external services gracefully. If an external API call fails, the lib function should catch it and either return a well-defined error object or throw a custom error with context. This way, the rest of the app can handle failures consistently. Consider logging important errors (using console.error or a logging service) in these modules, so that troubleshooting external integration issues is easier. However, avoid overly verbose logging that might leak sensitive info.
