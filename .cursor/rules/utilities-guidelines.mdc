---
description: "Guidelines for utility functions and modules in utils/, emphasizing pure functions, reusability, and avoiding side effects or duplication."
globs: utils/**/*
---
The `utils/` directory contains plain TypeScript/JavaScript utilities and helper functions. These are generic functions (not React-specific) that can be reused across the project. Adhere to the following when adding or editing utilities:

- **Pure Functions:** Utilities should ideally be **pure functions** that have clear input-output behavior and no side effects. For example, formatting functions, calculation helpers, data transformation functions should not depend on external state or modify global values. This makes them predictable and easy to test.
- **Single Responsibility:** Each utility function or module should tackle a specific task. If a utility file grows too large or handles disparate tasks, consider splitting it into multiple modules. For instance, you might have separate files like `utils/date.ts` for date formatting and `utils/string.ts` for string manipulation. Avoid one mega `helpers.ts` file; instead, group by domain or data type.
- **No Direct DOM or React Usage:** Utilities are for non-UI logic only. They should not manipulate the DOM or use React-specific APIs. If you find yourself needing to use browser APIs (like `window` or `document`) or React hooks in a utility, that’s a sign the code might belong in a hook or component instead. Keep utils environment-agnostic when possible (usable in Node.js or browser).
- **Avoid Duplicating Code:** Before writing a new utility function, check if one already exists to do the job. We want a single source of truth for common operations. For example, if formatting a date, ensure there's one `formatDate` utility rather than multiple implementations scattered in components. Consolidate logic in utils to avoid divergence and bugs.
- **Performance Considerations:** If a utility function will be called frequently or on large data sets (e.g., a sorting or filtering function), ensure it’s efficient. Use algorithms appropriate for the data size, and consider memoization or caching results if needed (though avoid premature optimization – only optimize if a performance issue is observed or expected). Document any non-obvious optimizations for future maintainers.
- **Type Safety and Contracts:** Leverage TypeScript to define clear input and output types for utilities. For instance, if a function takes a string and returns a specific object, define that in the type signature. If a utility can throw an error (e.g., parsing fails), document it and consider returning a `Result` type (like an `Either` pattern or a simple `{success: false, error: Error}` object) instead of throwing, so calling code can handle failures gracefully.
- **Documentation:** For complex utilities, add comments or JSDoc describing what they do and how to use them. This is especially useful for math-heavy functions or anything with tricky logic. A brief example in the comment can help future devs (and the AI assistant) understand usage.
- **Examples of Utilities:** Typical contents of `utils/` might include: formatting (dates, currencies), data structure manipulation (deepClone, deepMerge), validation functions (e.g., check if string is valid email), or small general helpers like `assertNever` for exhaustive switch checks. Keep these general-purpose; anything domain-specific might belong in a more specific module or context.
