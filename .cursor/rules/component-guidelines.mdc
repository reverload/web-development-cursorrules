---
description: "Standards for reusable UI components in the components/ directory, focusing on consistency, accessibility, and integration with Tailwind & Shadcn UI."
globs: components/**/*
---
The `components/` directory holds shared UI components. These should be building blocks of the UI, composed to create pages. Keep these guidelines in mind for all components:

- **Shadcn UI & Radix First:** Prefer using **shadcn-ui components** (which wrap Radix UI primitives) for common UI patterns. For example, use the provided `<Button>`, `<Dialog>`, `<DropdownMenu>`, etc., from the design system instead of creating new ones from scratch. This ensures consistent styling and behavior across the app (and comes with built-in accessibility). Only create a custom component if no existing component covers your use case. When building something custom, consider using **Radix UI primitives** directly to maintain accessibility and consistency (e.g. use Radix `<Popover>` if you need a popover that isn’t already provided by Shadcn).
- **Tailwind CSS Styling:** Use Tailwind utility classes for all styling in components. Avoid writing standalone CSS whenever possible. Leverage the design tokens and theme configured in Tailwind (colors, spacing, typography) to maintain consistency. For example, use classes like `text-sm font-medium text-primary` rather than hard-coding CSS values. If a particular style is repeated often, consider extracting a Tailwind component class or using `@apply` in a global CSS for that pattern (sparingly). **Do not** use inline styles or arbitrary values unless absolutely necessary.
- **Composition and Reuse:** Keep components **small, focused, and reusable**. Each component should ideally do one thing well. If you find a component becoming too complex or handling too many concerns, split it into smaller sub-components. Favor composition over inheritance – e.g., compose simpler components together rather than creating monolithic ones. Use children and props to make components flexible (for example, a `<Card>` component that accepts header and body content as children). However, avoid over-generalizing; the component should solve the needs at hand and you can extend it later if needed.
- **Accessibility in Components:** Ensure every component you build is accessible. This means adding appropriate ARIA attributes for custom controls (if you’re not using Radix primitives which often handle this). Examples: if you create a custom button or icon button, include `aria-label` or visible text for screen readers; ensure focus outlines are not removed and are visible; manage focus order in custom dialogs or popovers. For form components, always pair inputs with labels and use `aria-describedby` for additional hints or error messages. Test components with keyboard-only navigation to ensure all interactive elements can be reached and used.
- **Responsive & Adaptive Design:** Design components to be responsive by default. Use Tailwind’s responsive modifiers within components to adjust layouts (e.g., a `<Navbar>` that collapses into a menu on small screens). Ensure text scales and containers wrap or stack appropriately on smaller viewports. Consider using CSS grid or flex with Tailwind utilities to create fluid layouts. If a component has complex responsive behavior (for example, showing/hiding certain elements), encapsulate that logic within the component and use CSS or small amounts of client-side state as needed to toggle UI for different screen sizes.
- **State and Side Effects:** Prefer keeping components **stateless** or with minimal local state. For purely presentational components, pass data in as props and avoid internal state. For interactive components (like a dropdown or modal), manage state internally or via a hook, but keep it self-contained. If a component triggers side effects (like an analytics event on click), ensure those are handled in a way that doesn’t break the component’s reusability (perhaps via callback props or external handlers). Use **controlled components** for form inputs (with state lifted up when necessary) to maintain predictable data flow.
- **Error Boundaries in Interactive Components:** For components that perform asynchronous actions (like a data-fetching child component or a form submission within a component), consider wrapping them in an error boundary at a higher level if a failure in them should not crash the entire page. Typically, pages handle errors via `error.tsx`, but for deeply nested client components, you might use `<ErrorBoundary>` (from React or a library) to catch errors and display a fallback UI within that section of the page.
- **Naming and Organization:** Name components clearly after their purpose (e.g., `Modal.tsx`, `UserCard.tsx`, `Navbar.tsx`). If a component is specific to a feature and not reused, you might still keep it in the `components/` folder (or a subfolder within it) for clarity, or colocate it with the feature. Use subfolders to group related components (e.g., a `components/forms/` folder for form-related components like Input, Select, etc.). Each file should ideally export one main component (whose name matches the filename). Co-locate component-specific styles (if any) or sub-components in the same folder.
- **Testing Components:** (If tests are part of the project) Ensure components can be tested easily. This means avoiding hard-coded data fetching inside components – instead inject data via props or use hooks (which can be mocked). Keep side-effects in clearly defined places (like in a hook or callback) so that tests can simulate user interactions without needing a real backend. This isn’t a coding rule per se, but following the above patterns inherently makes components more predictable and testable.