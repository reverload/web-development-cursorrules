This project adheres to a **modern frontend stack** emphasizing consistency, performance, accessibility, and simplicity. The following global rules apply to **all files** in the repository:

- **Design System First:** Use the established design system everywhere. Leverage **Shadcn UI** components (built on Radix UI) and Tailwind CSS utility classes for all styling to ensure a consistent look and feel. Avoid custom CSS or third-party UI patterns that diverge from our system.
- **Keep it Simple & Elegant:** Favor straightforward solutions over clever over-engineering. Prioritize clarity and maintainability – write code that is easy to read and understand. **Avoid premature abstractions** or complex patterns unless absolutely necessary. If a simpler approach meets the requirements, use it.
- **Performance Optimization:** Always consider performance. **Use React Server Components (RSC)** and Next.js App Router features to minimize client-side JavaScript. Prefer server-side data fetching and rendering for better load times. Avoid expensive computations on the client; if needed, perform them on the server or in background threads.
- **TypeScript Strictness:** Embrace TypeScript for type safety. Enable **strict mode** and do not use `any` unless unavoidable. Define clear interfaces/types for props, state, and data structures in the `types/` folder. Catch errors early with proper typing rather than at runtime.
- **Accessibility (a11y) & UX:** All UI must be accessible and user-friendly. Use semantic HTML elements (e.g. buttons for actions, form labels, headings in logical order). Provide appropriate **ARIA labels**, alt text for images, and keyboard navigation support. Shadcn/Radix components are accessible by default – utilize them correctly (e.g. ensure `label` elements link to inputs, etc.). Validate that modals, dialogs, and other components trap focus and can be operated via keyboard.
- **Responsive Design:** Implement mobile-first, responsive layouts. Use Tailwind’s responsive utilities (e.g. `sm:`, `md:`, `lg:` breakpoints) to adapt UIs to different screen sizes. Test components on various devices/viewports to ensure content remains readable and functional on small screens up through large desktops. Avoid fixed pixel values that don’t scale; use relative units or Tailwind spacing values.
- **Consistent Naming & Structure:** Follow consistent naming conventions across files and folders. Use **PascalCase** for React component filenames and component names, **camelCase** for functions and variables, and **kebab-case** for folder names and non-component files. Hooks must start with `use...` and context providers end with `Provider`. Organize code by feature/domain where possible, but keep types, utils, and hooks in their dedicated folders for discoverability. Maintain the project’s file structure as defined (see scoped rules below) and place new files in appropriate directories.
- **State Management Principles:** Manage state in the **most appropriate scope** and avoid global state when unnecessary. Use React’s built-in state (useState, useReducer) for local component state. For cross-component or global state, prefer **React Context** or lightweight stores (e.g. Zustand) instead of heavy solutions like Redux, unless truly justified. Utilize **URL state** for persistent UI state when appropriate – e.g. use the `nuqs` library to keep filter/search state in the URL for shareability and back/forward navigation support.
- **Async and Data Handling:** Leverage Next.js **Server Actions** and RSC for data mutations and fetching to simplify client-side code. When using forms, handle submissions with server actions (instead of creating API routes) and track progress using React 19’s **`useActionState`** hook for instant loading and error UI. For client-side data fetching or more dynamic data needs, use **Tanstack Query (React Query)** to fetch/cache data and update the UI efficiently. Avoid duplicating data fetching logic across components; centralize it in hooks or utility functions.
- **Error Handling & Boundaries:** Write code that fails gracefully. Use try/catch in async functions (especially server actions and data fetching) to handle errors and return meaningful messages. In the UI, employ **error boundaries** – Next.js App Router provides `error.jsx` or `error.tsx` files in routes to catch errors during rendering; use these to show user-friendly error screens. Additionally, for interactive client components, consider using React’s `<ErrorBoundary>` (if needed) to catch runtime errors and display fallbacks rather than breaking the whole app.
- **Quality and Testing:** (General note) Ensure code quality with linting and formatting (respect the project ESLint/prettier rules). Write components and functions that are testable and consider adding unit or integration tests for critical pieces (though test implementation is outside the scope of these rules, the code should be structured to accommodate it). No console logs or debugging artifacts should be committed. Each piece of code should have a clear purpose and be documented with comments or JSDoc when its intent is not obvious.